const { exec } = require('child_process');
const fs = require('fs').promises;
const path = require('path');
const db = require('../config/database');
const { Client } = require('pg');

class UploadProcessor {
  constructor() {
    this.pgClient = null;
    this.padPath = 'C:\\Program Files (x86)\\Power Automate Desktop\\dotnet\\PAD.Console.Host.exe';
    this.flowName = 'ageagekun_kyotaku';
    this.baseDir = 'C:\\Users\\hyosh\\Desktop\\allright\\ageagekun\\patients';
  }

  // ãƒ—ãƒ­ã‚»ãƒƒã‚µãƒ¼ã‚’é–‹å§‹ï¼ˆã‚¤ãƒ™ãƒ³ãƒˆé§†å‹•å‹ï¼‰
  async start() {
    console.log('ğŸš€ Starting event-driven upload processor...');
    
    // PostgreSQL LISTENè¨­å®š
    await this.setupDatabaseListener();
    
    // èµ·å‹•æ™‚ã«æœªå‡¦ç†ã®ã‚¿ã‚¹ã‚¯ã‚’ãƒã‚§ãƒƒã‚¯
    await this.checkPendingTasks();
    
    console.log('âœ… Upload processor started (event-driven mode)');
  }

  // PostgreSQL LISTENè¨­å®š
  async setupDatabaseListener() {
    try {
      // å°‚ç”¨ã®PostgreSQLæ¥ç¶šã‚’ä½œæˆ
      this.pgClient = new Client({
        host: process.env.DB_HOST,
        port: process.env.DB_PORT,
        database: process.env.DB_NAME,
        user: process.env.DB_USER,
        password: process.env.DB_PASSWORD
      });
      
      await this.pgClient.connect();
      console.log('ğŸ”— Upload processor connected to PostgreSQL');
      
      // rpa_queue_eventsãƒãƒ£ãƒ³ãƒãƒ«ã‚’LISTEN
      await this.pgClient.query('LISTEN rpa_queue_events');
      console.log('ğŸ‘‚ Listening for queue events...');
      
      // NOTIFYã‚¤ãƒ™ãƒ³ãƒˆã‚’å‡¦ç†
      this.pgClient.on('notification', async (msg) => {
        if (msg.channel === 'rpa_queue_events') {
          try {
            const payload = JSON.parse(msg.payload);
            console.log('ğŸ“¢ Queue event received:', payload);
            
            // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã«å¿œã˜ã¦å‡¦ç†
            if (payload.status === 'pending') {
              // æ–°ã—ã„ã‚¿ã‚¹ã‚¯ãŒè¿½åŠ ã•ã‚ŒãŸ
              console.log('ğŸ†• New task detected, starting PAD...');
              await this.executePAD(payload.id);
            } else if (payload.status === 'done') {
              // PADãŒå®Œäº†ã—ãŸ
              console.log('âœ… Task completed by PAD');
              await this.handleTaskCompletion(payload.id);
            } else if (payload.status === 'failed') {
              // PADãŒå¤±æ•—ã—ãŸ
              console.log('âŒ Task failed');
              await this.checkNextTask();
            }
          } catch (error) {
            console.error('Failed to process notification:', error);
          }
        }
      });
      
    } catch (error) {
      console.error('Failed to setup database listener:', error);
      throw error;
    }
  }

  // èµ·å‹•æ™‚ã«æœªå‡¦ç†ã‚¿ã‚¹ã‚¯ã‚’ãƒã‚§ãƒƒã‚¯
  async checkPendingTasks() {
    try {
      const query = `
        SELECT q.id as queue_id
        FROM rpa_queue q
        WHERE q.status = 'pending'
        ORDER BY q.created_at
        LIMIT 1
      `;
      
      const result = await db.query(query);
      
      if (result.rows.length > 0) {
        console.log(`ğŸ“¦ Found pending task at startup: Queue #${result.rows[0].queue_id}`);
        await this.executePAD(result.rows[0].queue_id);
      } else {
        console.log('ğŸ“­ No pending tasks at startup');
      }
    } catch (error) {
      console.error('âŒ Error checking pending tasks:', error);
    }
  }

  // ã‚¿ã‚¹ã‚¯å®Œäº†å¾Œã®å‡¦ç†ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«ç§»å‹•ã¨æ¬¡ã®ã‚¿ã‚¹ã‚¯å®Ÿè¡Œï¼‰
  async handleTaskCompletion(queueId) {
    try {
      // ã‚¿ã‚¹ã‚¯æƒ…å ±ã‚’å–å¾—
      const taskQuery = `
        SELECT 
          q.id as queue_id,
          q.file_id,
          d.fileName,
          d.pass as file_path,
          d.patientID
        FROM rpa_queue q
        JOIN Documents d ON q.file_id = d.fileID
        WHERE q.id = $1
      `;
      
      const taskResult = await db.query(taskQuery, [queueId]);
      
      if (taskResult.rows.length > 0) {
        const task = taskResult.rows[0];
        
        // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã€Œuploadedã€ãƒ•ã‚©ãƒ«ãƒ€ã«ç§»å‹•
        await this.moveFileToUploaded(task);
        
        console.log(`ğŸ“ File moved to uploaded folder: ${task.filename}`);
      }
      
      // æ¬¡ã®pendingã‚¿ã‚¹ã‚¯ã‚’æ¢ã—ã¦å®Ÿè¡Œ
      await this.checkNextTask();
      
    } catch (error) {
      console.error('âŒ Error handling task completion:', error);
    }
  }

  // æ¬¡ã®ã‚¿ã‚¹ã‚¯ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦å®Ÿè¡Œ
  async checkNextTask() {
    try {
      const query = `
        SELECT q.id as queue_id
        FROM rpa_queue q
        WHERE q.status = 'pending'
        ORDER BY q.created_at
        LIMIT 1
      `;
      
      const result = await db.query(query);
      
      if (result.rows.length > 0) {
        const nextTask = result.rows[0];
        console.log(`\nğŸ”„ Starting next task: Queue #${nextTask.queue_id}`);
        await this.executePAD(nextTask.queue_id);
      } else {
        console.log('ğŸ“­ No more pending tasks');
      }
    } catch (error) {
      console.error('âŒ Error checking next task:', error);
    }
  }

  // PADãƒ•ãƒ­ãƒ¼ã‚’å®Ÿè¡Œ
  async executePAD(queueId) {
    try {
      // ã‚¿ã‚¹ã‚¯è©³ç´°ã‚’å–å¾—
      const taskQuery = `
        SELECT 
          q.id as queue_id,
          q.file_id,
          d.fileName,
          d.pass as file_path,
          d.patientID,
          d.Category
        FROM rpa_queue q
        JOIN Documents d ON q.file_id = d.fileID
        WHERE q.id = $1
      `;
      
      const result = await db.query(taskQuery, [queueId]);
      
      if (result.rows.length === 0) {
        console.error(`âŒ Task not found: ${queueId}`);
        return false;
      }
      
      const task = result.rows[0];
      
      return new Promise((resolve) => {
        // ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’åˆ†å‰²
        const baseDir = path.dirname(task.file_path);
        const fileName = path.basename(task.file_path);
        
        // PADç”¨ã®å…¥åŠ›å¼•æ•°ã‚’ä½œæˆï¼ˆJSONå½¢å¼ï¼‰
        const inputArgs = {
          queue_id: task.queue_id,
          PatientID: task.patientid,
          BaseDir: baseDir,
          fileName: fileName,
          Category: task.category
        };
        
        // URLå½¢å¼ã§ã‚³ãƒãƒ³ãƒ‰ã‚’ä½œæˆ
        const url = `ms-powerautomate:/console/flow/run?workflowName=${this.flowName}&inputArguments=${encodeURIComponent(JSON.stringify(inputArgs))}`;
        const args = `"${this.padPath}" "${url}"`;
        
        console.log(`\n${'='.repeat(60)}`);
        console.log(`ğŸ¤– PADå®Ÿè¡Œé–‹å§‹: ${new Date().toLocaleString('ja-JP')}`);
        console.log(`${'='.repeat(60)}`);
        console.log(`ğŸ“‹ Queue ID: ${task.queue_id}`);
        console.log(`ğŸ‘¤ Patient ID: ${task.patientid}`);
        console.log(`ğŸ“ Base Directory: ${baseDir}`);
        console.log(`ğŸ“„ File Name: ${fileName}`);
        console.log(`ğŸ·ï¸ Category: ${task.category}`);
        console.log(`${'='.repeat(60)}`);
        console.log(`â³ PADãƒ•ãƒ­ãƒ¼å®Ÿè¡Œä¸­...`);
        
        exec(args, (error, stdout, stderr) => {
          if (error) {
            console.error('âŒ PAD execution error:', error);
            resolve(false);
            return;
          }
          
          if (stderr) {
            console.error('âš ï¸ PAD stderr:', stderr);
          }
          
          if (stdout) {
            console.log('ğŸ“ PAD output:', stdout);
          }
          
          // PADãŒå®Œäº†ã—ãŸï¼ˆPADãŒã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’æ›´æ–°ã™ã‚‹ï¼‰
          console.log(`âœ… PADå®Ÿè¡Œå®Œäº†: ${new Date().toLocaleString('ja-JP')}`);
          console.log(`${'='.repeat(60)}\n`);
          resolve(true);
        });
      });
    } catch (error) {
      console.error('âŒ Error executing PAD:', error);
      return false;
    }
  }

  // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’uploadedãƒ•ã‚©ãƒ«ãƒ€ã«ç§»å‹•
  async moveFileToUploaded(task) {
    try {
      const oldPath = task.file_path;
      const fileName = path.basename(oldPath);
      const patientDir = path.dirname(oldPath);
      const uploadedDir = path.join(patientDir, 'uploaded');
      const newPath = path.join(uploadedDir, fileName);
      
      // uploadedãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ä½œæˆï¼ˆå­˜åœ¨ã—ãªã„å ´åˆï¼‰
      await fs.mkdir(uploadedDir, { recursive: true });
      
      // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç§»å‹•
      await fs.rename(oldPath, newPath);
      
      console.log(`ğŸ“ Moved file: ${fileName}`);
      console.log(`   From: ${oldPath}`);
      console.log(`   To: ${newPath}`);
      
      // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®ãƒ‘ã‚¹ã‚’æ›´æ–°
      await this.updateDocumentPath(task.file_id, newPath);
      
    } catch (error) {
      console.error('âŒ Error moving file:', error);
      throw error;
    }
  }

  // Documentsãƒ†ãƒ¼ãƒ–ãƒ«ã®ãƒ‘ã‚¹ã‚’æ›´æ–°
  async updateDocumentPath(fileId, newPath) {
    try {
      const query = `
        UPDATE Documents
        SET pass = $1,
            uploaded_at = CURRENT_TIMESTAMP
        WHERE fileID = $2
      `;
      
      await db.query(query, [newPath, fileId]);
      console.log(`âœ… Updated document path in database`);
      
    } catch (error) {
      console.error('âŒ Error updating document path:', error);
      throw error;
    }
  }

  // ãƒ—ãƒ­ã‚»ãƒƒã‚µãƒ¼ã‚’åœæ­¢
  async stop() {
    console.log('ğŸ›‘ Stopping upload processor...');
    
    if (this.pgClient) {
      await this.pgClient.end();
    }
    
    console.log('âœ… Upload processor stopped');
  }
}

module.exports = UploadProcessor;